/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
	"/api/auth/app/v1/tokens/refresh": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Refresh the access token
		 * @description Used to retrieve a new access token. Depending on `settings.HEADLESS_JWT_ROTATE_REFRESH_TOKEN`,
		 *     a new refresh token is returned as well.
		 */
		get: {
			parameters: {
				query?: never;
				header?: never;
				path?: never;
				cookie?: never;
			};
			requestBody?: components["requestBodies"]["RefreshToken"];
			responses: {
				200: components["responses"]["RefreshToken"];
				/** @description The refresh token is invalid or expired. */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ErrorResponse"];
					};
				};
			};
		};
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/auth/browser/v1/auth/provider/redirect": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Provider redirect
		 * @description Initiates the third-party provider authentication redirect flow. As calling
		 *     this endpoint results in a user facing redirect (302), this call is only
		 *     available in a browser, and must be called in a synchronous (non-XHR)
		 *     manner.
		 */
		post: {
			parameters: {
				query?: never;
				header?: never;
				path?: never;
				cookie?: never;
			};
			requestBody: components["requestBodies"]["ProviderRedirect"];
			responses: {
				/** @description The provider authorization URL to which the client should be redirected. */
				302: {
					headers: {
						/** @description The redirect URL. */
						location?: string;
						[name: string]: unknown;
					};
					content?: never;
				};
			};
		};
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/auth/{client}/v1/account/authenticators": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/** List authenticators */
		get: {
			parameters: {
				query?: never;
				header?: {
					/** @description Session token. Only needed when `client` is equal to `app`. */
					"X-Session-Token"?: components["parameters"]["SessionToken"];
				};
				path: {
					/** @description The type of client accessing the API. */
					client: components["parameters"]["Client"];
				};
				cookie?: never;
			};
			requestBody?: never;
			responses: {
				200: components["responses"]["Authenticators"];
				401: components["responses"]["Authentication"];
				410: components["responses"]["SessionGone"];
			};
		};
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/auth/{client}/v1/account/authenticators/recovery-codes": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * List recovery codes
		 * @description List recovery codes.
		 */
		get: {
			parameters: {
				query?: never;
				header?: {
					/** @description Session token. Only needed when `client` is equal to `app`. */
					"X-Session-Token"?: components["parameters"]["SessionToken"];
				};
				path: {
					/** @description The type of client accessing the API. */
					client: components["parameters"]["Client"];
				};
				cookie?: never;
			};
			requestBody?: never;
			responses: {
				200: components["responses"]["RecoveryCodes"];
				401: components["responses"]["ReauthenticationRequired"];
				404: components["responses"]["NotFound"];
			};
		};
		put?: never;
		/** Regenerate recovery codes */
		post: {
			parameters: {
				query?: never;
				header?: {
					/** @description Session token. Only needed when `client` is equal to `app`. */
					"X-Session-Token"?: components["parameters"]["SessionToken"];
				};
				path: {
					/** @description The type of client accessing the API. */
					client: components["parameters"]["Client"];
				};
				cookie?: never;
			};
			requestBody?: never;
			responses: {
				/** @description An input error occurred. */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ErrorResponse"];
					};
				};
				401: components["responses"]["ReauthenticationRequired"];
			};
		};
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/auth/{client}/v1/account/authenticators/totp": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * TOTP authenticator status
		 * @description Retrieve the information about the current TOTP authenticator, if any.
		 */
		get: {
			parameters: {
				query?: never;
				header?: {
					/** @description Session token. Only needed when `client` is equal to `app`. */
					"X-Session-Token"?: components["parameters"]["SessionToken"];
				};
				path: {
					/** @description The type of client accessing the API. */
					client: components["parameters"]["Client"];
				};
				cookie?: never;
			};
			requestBody?: never;
			responses: {
				200: components["responses"]["TOTPAuthenticator"];
				404: components["responses"]["TOTPAuthenticatorNotFound"];
				409: components["responses"]["AddAuthenticatorConflict"];
			};
		};
		put?: never;
		/**
		 * Activate TOTP
		 * @description The code should be provided from the consuming TOTP authenticator
		 *     application which was generated using the TOTP authenticator secret
		 *     retrieved from the TOTP authenticator status endpoint.
		 */
		post: {
			parameters: {
				query?: never;
				header?: {
					/** @description Session token. Only needed when `client` is equal to `app`. */
					"X-Session-Token"?: components["parameters"]["SessionToken"];
				};
				path: {
					/** @description The type of client accessing the API. */
					client: components["parameters"]["Client"];
				};
				cookie?: never;
			};
			requestBody?: components["requestBodies"]["SetupTOTP"];
			responses: {
				200: components["responses"]["TOTPAuthenticator"];
				/** @description An input error occurred. */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ErrorResponse"];
					};
				};
				401: components["responses"]["ReauthenticationRequired"];
				409: components["responses"]["AddAuthenticatorConflict"];
			};
		};
		/**
		 * Deactivate TOTP
		 * @description Deactivates TOTP authentication. If the user authentication is not
		 *     sufficiently recent, a reauthentication flow (`401`) will is presented.
		 */
		delete: {
			parameters: {
				query?: never;
				header?: {
					/** @description Session token. Only needed when `client` is equal to `app`. */
					"X-Session-Token"?: components["parameters"]["SessionToken"];
				};
				path: {
					/** @description The type of client accessing the API. */
					client: components["parameters"]["Client"];
				};
				cookie?: never;
			};
			requestBody?: never;
			responses: {
				200: components["responses"]["StatusOK"];
				401: components["responses"]["ReauthenticationRequired"];
			};
		};
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/auth/{client}/v1/account/email": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * List email addresses
		 * @description Retrieves the list of email addresses of the account.
		 */
		get: {
			parameters: {
				query?: never;
				header?: {
					/** @description Session token. Only needed when `client` is equal to `app`. */
					"X-Session-Token"?: components["parameters"]["SessionToken"];
				};
				path: {
					/** @description The type of client accessing the API. */
					client: components["parameters"]["Client"];
				};
				cookie?: never;
			};
			requestBody?: never;
			responses: {
				200: components["responses"]["EmailAddresses"];
				401: components["responses"]["Authentication"];
			};
		};
		/**
		 * Request email verification
		 * @description Requests for (another) email verification email to be sent. Note that
		 *     sending emails is rate limited, so when you send too many requests the
		 *     email will not be sent.
		 */
		put: {
			parameters: {
				query?: never;
				header?: {
					/** @description Session token. Only needed when `client` is equal to `app`. */
					"X-Session-Token"?: components["parameters"]["SessionToken"];
				};
				path: {
					/** @description The type of client accessing the API. */
					client: components["parameters"]["Client"];
				};
				cookie?: never;
			};
			requestBody?: components["requestBodies"]["Email"];
			responses: {
				200: components["responses"]["StatusOK"];
				/** @description An input error occurred. */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ErrorResponse"];
					};
				};
				/** @description Too many email verification mails were already sent. */
				403: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ForbiddenResponse"];
					};
				};
			};
		};
		/**
		 * Add/Change email address
		 * @description The following functionality is available:
		 *
		 *       - Adding a new email address for an already signed in user (`ACCOUNT_CHANGE_EMAIL = False`).
		 *       - Change to a new email address for an already signed in user   (`ACCOUNT_CHANGE_EMAIL = True`).
		 *       - Change to a new email address during the email verification process at signup (`ACCOUNT_EMAIL_VERIFICATION_SUPPORTS_CHANGE = True`).
		 *
		 *     In all cases, an email verification mail will be sent containing a link or code that needs to be verified.
		 */
		post: {
			parameters: {
				query?: never;
				header?: {
					/** @description Session token. Only needed when `client` is equal to `app`. */
					"X-Session-Token"?: components["parameters"]["SessionToken"];
				};
				path: {
					/** @description The type of client accessing the API. */
					client: components["parameters"]["Client"];
				};
				cookie?: never;
			};
			requestBody?: components["requestBodies"]["Email"];
			responses: {
				200: components["responses"]["EmailAddresses"];
				/** @description An input error occurred. */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ErrorResponse"];
					};
				};
				401: components["responses"]["AuthenticationOrReauthentication"];
				/** @description Conflict. For example, when no user is authenticated and no email verification flow is pending. */
				409: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ConflictResponse"];
					};
				};
			};
		};
		/**
		 * Remove an email address
		 * @description Used to remove an email address.
		 */
		delete: {
			parameters: {
				query?: never;
				header?: {
					/** @description Session token. Only needed when `client` is equal to `app`. */
					"X-Session-Token"?: components["parameters"]["SessionToken"];
				};
				path: {
					/** @description The type of client accessing the API. */
					client: components["parameters"]["Client"];
				};
				cookie?: never;
			};
			requestBody?: components["requestBodies"]["Email"];
			responses: {
				200: components["responses"]["EmailAddresses"];
				/** @description An input error occurred. */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ErrorResponse"];
					};
				};
			};
		};
		options?: never;
		head?: never;
		/**
		 * Change primary email address
		 * @description Used to change primary email address to a different one. Note that only verified email addresses
		 *     can be marked as primary.
		 */
		patch: {
			parameters: {
				query?: never;
				header?: {
					/** @description Session token. Only needed when `client` is equal to `app`. */
					"X-Session-Token"?: components["parameters"]["SessionToken"];
				};
				path: {
					/** @description The type of client accessing the API. */
					client: components["parameters"]["Client"];
				};
				cookie?: never;
			};
			requestBody?: components["requestBodies"]["MarkPrimaryEmail"];
			responses: {
				200: components["responses"]["EmailAddresses"];
				/** @description An input error occurred. */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ErrorResponse"];
					};
				};
			};
		};
		trace?: never;
	};
	"/api/auth/{client}/v1/account/password/change": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Change password
		 * @description In order to change the password of an account, the current and new
		 *     password must be provider.  However, accounts that were created by
		 *     signing up using a third-party provider do not have a password set. In
		 *     that case, the current password is not required.
		 */
		post: {
			parameters: {
				query?: never;
				header?: {
					/** @description Session token. Only needed when `client` is equal to `app`. */
					"X-Session-Token"?: components["parameters"]["SessionToken"];
				};
				path: {
					/** @description The type of client accessing the API. */
					client: components["parameters"]["Client"];
				};
				cookie?: never;
			};
			requestBody?: components["requestBodies"]["ChangePassword"];
			responses: {
				400: components["responses"]["Error"];
				401: components["responses"]["Authentication"];
			};
		};
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/auth/{client}/v1/account/phone": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Get the phone number
		 * @description Retrieves the phone number of the account, if any. Note that while the
		 *     endpoint returns a list of phone numbers, at most one entry is returned.
		 */
		get: {
			parameters: {
				query?: never;
				header?: {
					/** @description Session token. Only needed when `client` is equal to `app`. */
					"X-Session-Token"?: components["parameters"]["SessionToken"];
				};
				path: {
					/** @description The type of client accessing the API. */
					client: components["parameters"]["Client"];
				};
				cookie?: never;
			};
			requestBody?: never;
			responses: {
				200: components["responses"]["PhoneNumbers"];
				401: components["responses"]["Authentication"];
			};
		};
		put?: never;
		/**
		 * Change the phone number
		 * @description The following functionality is available:
		 *
		 *     - Initiate the phone number change process for signed in users.
		 *     - Change to a new phone number during the phone number verification
		 *       process at signup for unauthenticated users. Note that this requires:
		 *       `ACCOUNT_PHONE_VERIFICATION_SUPPORTS_CHANGE = True`.
		 *
		 *     In both cases, after posting a new phone number, proceed with the phone
		 *     verification endpoint to confirm the change of the phone number by
		 *     posting the verification code.
		 */
		post: {
			parameters: {
				query?: never;
				header?: {
					/** @description Session token. Only needed when `client` is equal to `app`. */
					"X-Session-Token"?: components["parameters"]["SessionToken"];
				};
				path: {
					/** @description The type of client accessing the API. */
					client: components["parameters"]["Client"];
				};
				cookie?: never;
			};
			requestBody?: components["requestBodies"]["Phone"];
			responses: {
				/** @description Phone number change process initiated. */
				202: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["PhoneNumberChangeResponse"];
					};
				};
				/** @description An input error occurred. */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ErrorResponse"];
					};
				};
				401: components["responses"]["AuthenticationOrReauthentication"];
				/** @description Conflict. For example, when no user is authenticated and no phone verification flow is pending. */
				409: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ConflictResponse"];
					};
				};
			};
		};
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/auth/{client}/v1/account/providers": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/** List the connected third-party provider accounts */
		get: {
			parameters: {
				query?: never;
				header?: {
					/** @description Session token. Only needed when `client` is equal to `app`. */
					"X-Session-Token"?: components["parameters"]["SessionToken"];
				};
				path: {
					/** @description The type of client accessing the API. */
					client: components["parameters"]["Client"];
				};
				cookie?: never;
			};
			requestBody?: never;
			responses: {
				200: components["responses"]["ProviderAccounts"];
			};
		};
		put?: never;
		post?: never;
		/**
		 * Disconnect a third-party provider account
		 * @description Disconnect a third-party provider account, returning the remaining
		 *     accounts that are still connected. The disconnect is not allowed if it
		 *     would leave the account unusable. For example, if no password was
		 *     set up yet.
		 */
		delete: {
			parameters: {
				query?: never;
				header?: {
					/** @description Session token. Only needed when `client` is equal to `app`. */
					"X-Session-Token"?: components["parameters"]["SessionToken"];
				};
				path: {
					/** @description The type of client accessing the API. */
					client: components["parameters"]["Client"];
				};
				cookie?: never;
			};
			requestBody?: components["requestBodies"]["ProviderAccount"];
			responses: {
				200: components["responses"]["ProviderAccounts"];
				/** @description An input error occurred. */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ErrorResponse"];
					};
				};
			};
		};
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/auth/{client}/v1/auth/2fa/authenticate": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Two-factor authentication
		 * @description If, during authentication,  a response with status 401 is encountered where one of the pending
		 *     flows has ID `mfa_authenticate`, that indicates that the Two-Factor Authentication stage needs to
		 *     be completed.
		 */
		post: {
			parameters: {
				query?: never;
				header?: {
					/** @description Session token. Only needed when `client` is equal to `app`. */
					"X-Session-Token"?: components["parameters"]["SessionToken"];
				};
				path: {
					/** @description The type of client accessing the API. */
					client: components["parameters"]["Client"];
				};
				cookie?: never;
			};
			requestBody: components["requestBodies"]["MFAAuthenticate"];
			responses: {
				200: components["responses"]["AuthenticatedByPasswordAnd2FA"];
				/** @description An input error occurred. */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ErrorResponse"];
					};
				};
				401: components["responses"]["Authentication"];
			};
		};
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/auth/{client}/v1/auth/2fa/reauthenticate": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Reauthenticate using 2FA
		 * @description In order to safeguard the account, some actions require the user to be
		 *     recently authenticated.  If you try to perform such an action without
		 *     having been recently authenticated, a `401` status is returned, listing
		 *     flows that can be performed to reauthenticate. One such flow is the flow
		 *     with ID `mfa_reauthenticate`, which allows for the user to input an
		 *     authenticator code (e.g. TOTP or recovery code). This is the endpoint
		 *     related towards that flow.
		 */
		post: {
			parameters: {
				query?: never;
				header?: {
					/** @description Session token. Only needed when `client` is equal to `app`. */
					"X-Session-Token"?: components["parameters"]["SessionToken"];
				};
				path: {
					/** @description The type of client accessing the API. */
					client: components["parameters"]["Client"];
				};
				cookie?: never;
			};
			requestBody: components["requestBodies"]["MFAAuthenticate"];
			responses: {
				200: components["responses"]["AuthenticatedByPasswordAnd2FA"];
				/** @description An input error occurred. */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ErrorResponse"];
					};
				};
			};
		};
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/auth/{client}/v1/auth/code/confirm": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Confirm login code
		 * @description Use this endpoint to pass along the received "special" login code.
		 */
		post: {
			parameters: {
				query?: never;
				header?: never;
				path: {
					/** @description The type of client accessing the API. */
					client: components["parameters"]["Client"];
				};
				cookie?: never;
			};
			requestBody: components["requestBodies"]["ConfirmLoginCode"];
			responses: {
				200: components["responses"]["AuthenticatedByCode"];
				/** @description An input error occurred. */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ErrorResponse"];
					};
				};
				/** @description Not authenticated. */
				401: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["AuthenticationResponse"];
					};
				};
				/** @description Conflict. The "login by code" flow is not pending. */
				409: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ConflictResponse"];
					};
				};
			};
		};
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/auth/{client}/v1/auth/email/verify": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Get email verification information
		 * @description Obtain email verification information, given the token that was sent to
		 *     the user by email.
		 */
		get: {
			parameters: {
				query?: never;
				header: {
					/** @description The email verification key */
					"X-Email-Verification-Key": components["parameters"]["EmailVerificationKey"];
				};
				path: {
					/** @description The type of client accessing the API. */
					client: components["parameters"]["Client"];
				};
				cookie?: never;
			};
			requestBody?: never;
			responses: {
				200: components["responses"]["EmailVerificationInfo"];
				/** @description An input error occurred. */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ErrorResponse"];
					};
				};
				/** @description Conflict. The email verification (by code) flow is not pending. */
				409: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ConflictResponse"];
					};
				};
			};
		};
		put?: never;
		/**
		 * Verify an email
		 * @description Complete the email verification process. Depending on the configuration,
		 *     email addresses are either verified by opening a link that is sent to
		 *     their email address, or, by inputting a code that is sent. On the API,
		 *     both cases are handled identically. Meaning, the required key is either
		 *     the one from the link, or, the code itself.
		 *
		 *     Note that a status code of 401 does not imply failure. It indicates that
		 *     the email verification was successful, yet, the user is still not signed
		 *     in. For example, in case `ACCOUNT_LOGIN_ON_EMAIL_CONFIRMATION` is set to
		 *     `False`, a 401 is returned when verifying as part of login/signup.
		 */
		post: {
			parameters: {
				query?: never;
				header?: {
					/** @description Session token. Only needed when `client` is equal to `app`. */
					"X-Session-Token"?: components["parameters"]["SessionToken"];
				};
				path: {
					/** @description The type of client accessing the API. */
					client: components["parameters"]["Client"];
				};
				cookie?: never;
			};
			requestBody?: components["requestBodies"]["VerifyEmail"];
			responses: {
				200: components["responses"]["Authenticated"];
				/** @description An input error occurred. */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ErrorResponse"];
					};
				};
				401: components["responses"]["Unauthenticated"];
				/** @description Conflict. The email verification (by code) flow is not pending. */
				409: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ConflictResponse"];
					};
				};
			};
		};
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/auth/{client}/v1/auth/email/verify/resend": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Resend email verification code
		 * @description Requests a new email verification code.
		 *     Requires `ACCOUNT_EMAIL_VERIFICATION_SUPPORTS_RESEND = True`.
		 */
		post: {
			parameters: {
				query?: never;
				header?: {
					/** @description Session token. Only needed when `client` is equal to `app`. */
					"X-Session-Token"?: components["parameters"]["SessionToken"];
				};
				path: {
					/** @description The type of client accessing the API. */
					client: components["parameters"]["Client"];
				};
				cookie?: never;
			};
			requestBody?: never;
			responses: {
				200: components["responses"]["StatusOK"];
				/** @description Conflict. The email verification (by code) flow is not pending. */
				409: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ConflictResponse"];
					};
				};
				429: components["responses"]["TooManyRequests"];
			};
		};
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/auth/{client}/v1/auth/login": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Login
		 * @description Login using a username-password or email-password combination.
		 */
		post: {
			parameters: {
				query?: never;
				header?: never;
				path: {
					/** @description The type of client accessing the API. */
					client: components["parameters"]["Client"];
				};
				cookie?: never;
			};
			requestBody: components["requestBodies"]["Login"];
			responses: {
				200: components["responses"]["AuthenticatedByPassword"];
				/** @description An input error occurred. */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ErrorResponse"];
					};
				};
				/** @description Not authenticated. */
				401: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["AuthenticationResponse"];
					};
				};
				/** @description Conflict. For example, when logging in when a user is already logged in. */
				409: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ConflictResponse"];
					};
				};
			};
		};
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/auth/{client}/v1/auth/password/request": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Request password
		 * @description Initiates the password reset procedure. Depending on whether or not
		 *     `ACCOUNT_PASSWORD_RESET_BY_CODE_ENABLED` is `True`, the procedure is
		 *     either stateless or stateful.
		 *
		 *     In case codes are used, it is stateful, and a new
		 *     `password_reset_by_code` flow is started. In this case, on a successful
		 *     password reset request, you will receive a 401 indicating the pending
		 *     status of this flow.
		 *
		 *     In case password reset is configured to use (stateless) links, you will
		 *     receive a 200 on a successful password reset request.
		 */
		post: {
			parameters: {
				query?: never;
				header?: never;
				path: {
					/** @description The type of client accessing the API. */
					client: components["parameters"]["Client"];
				};
				cookie?: never;
			};
			requestBody: components["requestBodies"]["RequestPassword"];
			responses: {
				200: components["responses"]["StatusOK"];
				/** @description An input error occurred. */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ErrorResponse"];
					};
				};
				401: components["responses"]["Authentication"];
			};
		};
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/auth/{client}/v1/auth/password/reset": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Get password reset information
		 * @description Used to obtain information on and validate a password reset key.  The
		 *     key passed is either the key encoded in the password reset URL that the
		 *     user has received per email, or, the password reset code in case of
		 *     `ACCOUNT_PASSWORD_RESET_BY_CODE_ENABLED`. Note that in case of a code,
		 *     the number of requests you can make is limited (by
		 *     `ACCOUNT_PASSWORD_RESET_BY_CODE_MAX_ATTEMPTS`).
		 */
		get: {
			parameters: {
				query?: never;
				header: {
					/** @description The password reset key */
					"X-Password-Reset-Key": components["parameters"]["PasswordResetKey"];
				};
				path: {
					/** @description The type of client accessing the API. */
					client: components["parameters"]["Client"];
				};
				cookie?: never;
			};
			requestBody?: never;
			responses: {
				200: components["responses"]["PasswordResetInfo"];
				/** @description An input error occurred. */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ErrorResponse"];
					};
				};
				/** @description Conflict. There is no password reset (by code) flow pending. */
				409: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ConflictResponse"];
					};
				};
			};
		};
		put?: never;
		/**
		 * Reset password
		 * @description Perform the password reset, by handing over the password reset key and
		 *     the new password. After successfully completing the password reset, the
		 *     user is either logged in (in case `ACCOUNT_LOGIN_ON_PASSWORD_RESET` is
		 *     `True`), or, the user will need to proceed to the login page.  In case
		 *     of the former, a `200` status code is returned, in case of the latter a
		 *     401.
		 */
		post: {
			parameters: {
				query?: never;
				header?: never;
				path: {
					/** @description The type of client accessing the API. */
					client: components["parameters"]["Client"];
				};
				cookie?: never;
			};
			requestBody?: components["requestBodies"]["ResetPassword"];
			responses: {
				200: components["responses"]["AuthenticatedByPassword"];
				/** @description An input error occurred. */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ErrorResponse"];
					};
				};
				401: components["responses"]["Authentication"];
				/** @description Conflict. There is no password reset (by code) flow pending. */
				409: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ConflictResponse"];
					};
				};
			};
		};
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/auth/{client}/v1/auth/phone/verify": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Verify a phone number
		 * @description Complete the phone number verification process. Note that a status code
		 *     of 401 does not imply failure. It merely indicates that the phone number
		 *     verification was successful, yet, the user is still not signed in.
		 */
		post: {
			parameters: {
				query?: never;
				header?: {
					/** @description Session token. Only needed when `client` is equal to `app`. */
					"X-Session-Token"?: components["parameters"]["SessionToken"];
				};
				path: {
					/** @description The type of client accessing the API. */
					client: components["parameters"]["Client"];
				};
				cookie?: never;
			};
			requestBody?: components["requestBodies"]["VerifyPhone"];
			responses: {
				200: components["responses"]["Authenticated"];
				/** @description An input error occurred. */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ErrorResponse"];
					};
				};
				401: components["responses"]["Unauthenticated"];
				/** @description Conflict. The phone verification flow is not pending. */
				409: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ConflictResponse"];
					};
				};
			};
		};
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/auth/{client}/v1/auth/phone/verify/resend": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Resend phone number verification code
		 * @description Requests a new phone number verification code.
		 *     Requires `ACCOUNT_PHONE_VERIFICATION_SUPPORTS_RESEND = True`.
		 */
		post: {
			parameters: {
				query?: never;
				header?: {
					/** @description Session token. Only needed when `client` is equal to `app`. */
					"X-Session-Token"?: components["parameters"]["SessionToken"];
				};
				path: {
					/** @description The type of client accessing the API. */
					client: components["parameters"]["Client"];
				};
				cookie?: never;
			};
			requestBody?: never;
			responses: {
				200: components["responses"]["StatusOK"];
				/** @description Conflict. The phone verification flow is not pending. */
				409: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ConflictResponse"];
					};
				};
				429: components["responses"]["TooManyRequests"];
			};
		};
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/auth/{client}/v1/auth/provider/signup": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Provider signup information
		 * @description If, while signing up using a third-party provider account, there is
		 *     insufficient information received from the provider to automatically
		 *     complete the signup process, an additional step is needed to complete
		 *     the missing data before the user is fully signed up and authenticated.
		 *     The information available so far, such as the pending provider account,
		 *     can be retrieved via this endpoint.
		 */
		get: {
			parameters: {
				query?: never;
				header?: never;
				path: {
					/** @description The type of client accessing the API. */
					client: components["parameters"]["Client"];
				};
				cookie?: never;
			};
			requestBody?: never;
			responses: {
				200: components["responses"]["ProviderSignup"];
				/** @description Conflict. The provider signup flow is not pending. */
				409: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ConflictResponse"];
					};
				};
			};
		};
		put?: never;
		/**
		 * Provider signup
		 * @description If, while signing up using a third-party provider account, there is
		 *     insufficient information received from the provider to automatically
		 *     complete the signup process, an additional step is needed to complete
		 *     the missing data before the user is fully signed up and authenticated.
		 */
		post: {
			parameters: {
				query?: never;
				header?: never;
				path: {
					/** @description The type of client accessing the API. */
					client: components["parameters"]["Client"];
				};
				cookie?: never;
			};
			requestBody: components["requestBodies"]["ProviderSignup"];
			responses: {
				200: components["responses"]["Authenticated"];
				/** @description An input error occurred. */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ErrorResponse"];
					};
				};
				/** @description Not authenticated, more steps are required to be completed. */
				401: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["AuthenticationResponse"];
					};
				};
				/** @description Forbidden. For example, when signup is closed. */
				403: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ForbiddenResponse"];
					};
				};
				/** @description Conflict. The provider signup flow is not pending. */
				409: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ConflictResponse"];
					};
				};
			};
		};
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/auth/{client}/v1/auth/provider/token": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Provider token
		 * @description Authenticates with a third-party provider using provider tokens received
		 *     by other means. For example, in case of a mobile app, the authentication
		 *     flow runs completely on the device itself, without any interaction with
		 *     the API. Then, when the (device) authentication completes and the mobile
		 *     app receives an access and/or ID token, it can hand over these tokens
		 *     via this endpoint to authenticate on the server.
		 */
		post: {
			parameters: {
				query?: never;
				header?: {
					/** @description Session token. Only needed when `client` is equal to `app`. */
					"X-Session-Token"?: components["parameters"]["SessionToken"];
				};
				path: {
					/** @description The type of client accessing the API. */
					client: components["parameters"]["Client"];
				};
				cookie?: never;
			};
			requestBody: components["requestBodies"]["ProviderToken"];
			responses: {
				200: components["responses"]["Authenticated"];
				/** @description An input error occurred. */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ErrorResponse"];
					};
				};
				/** @description Not authenticated, more steps are required to be completed. */
				401: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["AuthenticationResponse"];
					};
				};
				/** @description Forbidden. For example, when signup is closed. */
				403: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ForbiddenResponse"];
					};
				};
			};
		};
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/auth/{client}/v1/auth/reauthenticate": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Reauthenticate
		 * @description In order to safeguard the account, some actions require the user to be
		 *     recently authenticated.  If you try to perform such an action without
		 *     having been recently authenticated, a `401` status is returned, listing
		 *     flows that can be performed to reauthenticate. One such flow is the flow
		 *     with ID `reauthenticate`, which allows for the user to input the
		 *     password. This is the endpoint related towards that flow.
		 */
		post: {
			parameters: {
				query?: never;
				header?: {
					/** @description Session token. Only needed when `client` is equal to `app`. */
					"X-Session-Token"?: components["parameters"]["SessionToken"];
				};
				path: {
					/** @description The type of client accessing the API. */
					client: components["parameters"]["Client"];
				};
				cookie?: never;
			};
			requestBody: components["requestBodies"]["Reauthenticate"];
			responses: {
				200: components["responses"]["AuthenticatedByPassword"];
				/** @description An input error occurred. */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ErrorResponse"];
					};
				};
			};
		};
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/auth/{client}/v1/auth/session": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Get authentication status
		 * @description Retrieve information about the authentication status for the current
		 *     session.
		 */
		get: {
			parameters: {
				query?: never;
				header?: {
					/** @description Session token. Only needed when `client` is equal to `app`. */
					"X-Session-Token"?: components["parameters"]["SessionToken"];
				};
				path: {
					/** @description The type of client accessing the API. */
					client: components["parameters"]["Client"];
				};
				cookie?: never;
			};
			requestBody?: never;
			responses: {
				200: components["responses"]["Authenticated"];
				401: components["responses"]["Authentication"];
				410: components["responses"]["SessionGone"];
			};
		};
		put?: never;
		post?: never;
		/**
		 * Logout
		 * @description Logs out the user from the current session.
		 */
		delete: {
			parameters: {
				query?: never;
				header?: {
					/** @description Session token. Only needed when `client` is equal to `app`. */
					"X-Session-Token"?: components["parameters"]["SessionToken"];
				};
				path: {
					/** @description The type of client accessing the API. */
					client: components["parameters"]["Client"];
				};
				cookie?: never;
			};
			requestBody?: never;
			responses: {
				401: components["responses"]["Unauthenticated"];
			};
		};
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/auth/{client}/v1/auth/sessions": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/** List sessions */
		get: {
			parameters: {
				query?: never;
				header?: {
					/** @description Session token. Only needed when `client` is equal to `app`. */
					"X-Session-Token"?: components["parameters"]["SessionToken"];
				};
				path: {
					/** @description The type of client accessing the API. */
					client: components["parameters"]["Client"];
				};
				cookie?: never;
			};
			requestBody?: never;
			responses: {
				200: components["responses"]["Sessions"];
			};
		};
		put?: never;
		post?: never;
		/** End one or more sessions */
		delete: {
			parameters: {
				query?: never;
				header?: {
					/** @description Session token. Only needed when `client` is equal to `app`. */
					"X-Session-Token"?: components["parameters"]["SessionToken"];
				};
				path: {
					/** @description The type of client accessing the API. */
					client: components["parameters"]["Client"];
				};
				cookie?: never;
			};
			requestBody: components["requestBodies"]["EndSessions"];
			responses: {
				200: components["responses"]["Sessions"];
				401: components["responses"]["Authentication"];
			};
		};
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/auth/{client}/v1/auth/signup": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Signup
		 * @description Whether or not `username`, `email`, `phone` or combination of those are
		 *     required depends on the configuration of django-allauth. Additionally,
		 *     if a custom signup form is used there may be other custom properties
		 *     required.
		 */
		post: {
			parameters: {
				query?: never;
				header?: never;
				path: {
					/** @description The type of client accessing the API. */
					client: components["parameters"]["Client"];
				};
				cookie?: never;
			};
			requestBody: components["requestBodies"]["Signup"];
			responses: {
				200: components["responses"]["AuthenticatedByPassword"];
				/** @description An input error occurred. */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ErrorResponse"];
					};
				};
				/** @description Not authenticated. */
				401: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["AuthenticationResponse"];
					};
				};
				/** @description Forbidden. For example, when signup is closed. */
				403: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ForbiddenResponse"];
					};
				};
				/** @description Conflict. For example, when signing up while user is logged in. */
				409: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ConflictResponse"];
					};
				};
			};
		};
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/auth/{client}/v1/config": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Get configuration
		 * @description There are many configuration options that alter the functionality
		 *     and behavior of django-allauth, some of which can also impact the
		 *     frontend. Therefore, relevant configuration options are exposed via
		 *     this endpoint. The data returned is not user/authentication
		 *     dependent. Hence, it suffices to only fetch this data once at boot
		 *     time of your application.
		 */
		get: {
			parameters: {
				query?: never;
				header?: never;
				path: {
					/** @description The type of client accessing the API. */
					client: components["parameters"]["Client"];
				};
				cookie?: never;
			};
			requestBody?: never;
			responses: {
				200: components["responses"]["Configuration"];
			};
		};
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
}
export type webhooks = Record<string, never>;
export interface components {
	schemas: {
		/**
		 * @description The access token.
		 * @example eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdW
		 */
		AccessToken: string;
		/** @description Configuration of the Django `allauth.account` app. */
		AccountConfiguration: {
			email_verification_by_code_enabled: boolean;
			is_open_for_signup: boolean;
			login_by_code_enabled: boolean;
			login_methods?: ("email" | "username")[];
			password_reset_by_code_enabled?: boolean;
		};
		Authenticated: {
			/** @description A list of methods used to authenticate. */
			methods: components["schemas"]["AuthenticationMethod"][];
			user: components["schemas"]["User"];
		};
		AuthenticatedMeta: components["schemas"]["BaseAuthenticationMeta"] & {
			/** @enum {boolean} */
			is_authenticated: true;
		};
		AuthenticatedResponse: {
			data: components["schemas"]["Authenticated"];
			meta: components["schemas"]["AuthenticationMeta"];
			status: components["schemas"]["StatusOK"];
		};
		AuthenticationMeta: components["schemas"]["BaseAuthenticationMeta"] & {
			is_authenticated: boolean;
		};
		AuthenticationMethod:
			| {
					at: components["schemas"]["Timestamp"];
					email?: components["schemas"]["Email"];
					/** @enum {string} */
					method: "password";
					username?: components["schemas"]["Username"];
			  }
			| {
					at: components["schemas"]["Timestamp"];
					email: components["schemas"]["Email"];
					/** @enum {string} */
					method: "password_reset";
			  }
			| {
					at: components["schemas"]["Timestamp"];
					email: components["schemas"]["Email"];
					/** @enum {string} */
					method: "code";
			  }
			| {
					at: components["schemas"]["Timestamp"];
					/** @enum {string} */
					method: "code";
					phone: components["schemas"]["Phone"];
			  }
			| {
					at: components["schemas"]["Timestamp"];
					/** @enum {string} */
					method: "password";
					/** @enum {boolean} */
					reauthenticated: true;
			  }
			| {
					at: components["schemas"]["Timestamp"];
					/** @enum {string} */
					method: "socialaccount";
					provider: components["schemas"]["ProviderID"];
					uid: components["schemas"]["ProviderAccountID"];
			  }
			| {
					at: components["schemas"]["Timestamp"];
					/** @enum {string} */
					method: "mfa";
					reauthenticated?: boolean;
					type: components["schemas"]["AuthenticatorType"];
			  };
		/** @description An authentication related response. */
		AuthenticationResponse: {
			data: {
				flows: components["schemas"]["Flow"][];
			};
			meta: components["schemas"]["AuthenticationMeta"];
			/** @enum {integer} */
			status: 401;
		};
		/**
		 * @description An authenticator code.
		 * @example 314159
		 */
		AuthenticatorCode: string;
		/**
		 * @description Authenticator ID.
		 * @example 123
		 */
		AuthenticatorID: number;
		AuthenticatorList: (
			| components["schemas"]["TOTPAuthenticator"]
			| components["schemas"]["RecoveryCodesAuthenticator"]
			| components["schemas"]["WebAuthnAuthenticator"]
		)[];
		/**
		 * @description The type of authenticator.
		 * @enum {string}
		 */
		AuthenticatorType: "recovery_codes" | "totp" | "webauthn";
		BaseAuthenticationMeta: {
			/**
			 * @description The access token (`app` clients only).
			 * @example eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdW
			 */
			access_token?: string;
			/**
			 * @description The session token (`app` clients only).
			 * @example ufwcig0zen9skyd545jc0fkq813ghar2
			 */
			session_token?: string;
		};
		BaseAuthenticator: {
			created_at: components["schemas"]["Timestamp"];
			last_used_at: components["schemas"]["OptionalTimestamp"];
		};
		BaseSignup: {
			email: components["schemas"]["Email"];
		};
		/**
		 * @description The client ID (in case of OAuth2 or OpenID Connect based providers)
		 * @example 123.apps.googleusercontent.com
		 */
		ClientID: string;
		/**
		 * @description An one-time code.
		 * @example NQ3TM5
		 */
		Code: string;
		/**
		 * @example {
		 *       "data": {
		 *         "account": {
		 *           "authentication_method": "email"
		 *         },
		 *         "mfa": {
		 *           "supported_types": [
		 *             "recovery_codes",
		 *             "totp"
		 *           ]
		 *         },
		 *         "socialaccount": {
		 *           "providers": [
		 *             {
		 *               "client_id": "123.apps.googleusercontent.com",
		 *               "flows": [
		 *                 "provider_redirect",
		 *                 "provider_token"
		 *               ],
		 *               "id": "google",
		 *               "name": "Google",
		 *               "openid_configuration_url": "https://accounts.google.com/.well-known/openid-configuration"
		 *             }
		 *           ]
		 *         },
		 *         "usersessions": {
		 *           "track_activity": false
		 *         }
		 *       },
		 *       "status": 200
		 *     }
		 */
		ConfigurationResponse: {
			data: {
				account: components["schemas"]["AccountConfiguration"];
				mfa?: components["schemas"]["MFAConfiguration"];
				socialaccount?: components["schemas"]["SocialAccountConfiguration"];
				usersessions?: components["schemas"]["UserSessionsConfiguration"];
			};
			status: components["schemas"]["StatusOK"];
		};
		ConfirmLoginCode: {
			code: components["schemas"]["Code"];
		};
		ConflictResponse: {
			/** @enum {integer} */
			status: 409;
		};
		/**
		 * @description The email address.
		 * @example email@domain.org
		 */
		Email: string;
		EmailAddress: {
			email: components["schemas"]["Email"];
			/** @example true */
			primary: boolean;
			/** @example false */
			verified: boolean;
		};
		EmailVerificationInfo: {
			data: {
				email: components["schemas"]["Email"];
				user: components["schemas"]["User"];
			};
			meta: {
				is_authenticating: boolean;
			};
			status: components["schemas"]["StatusOK"];
		};
		EndSessions: {
			/** @description The IDs of the sessions that are to be ended. */
			sessions: number[];
		};
		ErrorResponse: {
			errors?: {
				/**
				 * @description An error code.
				 * @example invalid
				 */
				code: string;
				/**
				 * @description A human readable error message.
				 * @example Enter a valid email address.
				 */
				message: string;
				/**
				 * @description The name of the input parameter that was incorrect.
				 * @example email
				 */
				param?: string;
			}[];
			/**
			 * @example 400
			 * @enum {integer}
			 */
			status?: 400;
		};
		Flow: {
			/** @enum {string} */
			id:
				| "login"
				| "login_by_code"
				| "mfa_authenticate"
				| "mfa_reauthenticate"
				| "provider_redirect"
				| "provider_signup"
				| "provider_token"
				| "reauthenticate"
				| "signup"
				| "verify_email"
				| "verify_phone";
			/** @enum {boolean} */
			is_pending?: true;
			provider?: components["schemas"]["Provider"];
			/** @description Matches `settings.MFA_SUPPORTED_TYPES`. */
			types?: components["schemas"]["AuthenticatorType"][];
		};
		ForbiddenResponse: {
			/** @enum {integer} */
			status: 403;
		};
		Login: {
			password: components["schemas"]["Password"];
		} & (
			| {
					username: components["schemas"]["Username"];
			  }
			| {
					email: components["schemas"]["Email"];
			  }
			| {
					phone: components["schemas"]["Phone"];
			  }
		);
		MFAAuthenticate: {
			code: components["schemas"]["AuthenticatorCode"];
		};
		/** @description Configuration of the Django `allauth.mfa` app. */
		MFAConfiguration: {
			/** @description Matches `settings.MFA_SUPPORTED_TYPES`. */
			supported_types: components["schemas"]["AuthenticatorType"][];
		};
		MFATrust: {
			trust: boolean;
		};
		OptionalTimestamp: components["schemas"]["Timestamp"];
		PasskeySignup: components["schemas"]["BaseSignup"];
		/**
		 * @description The password.
		 * @example Alohomora!
		 */
		Password: string;
		/**
		 * @description The phone number.
		 * @example +314159265359
		 */
		Phone: string;
		/** @description A phone number. */
		PhoneNumber: {
			/** @example +314159265359 */
			phone: string;
			verified: boolean;
		};
		/**
		 * @example {
		 *       "data": [
		 *         {
		 *           "phone": "+314159265359",
		 *           "verified": false
		 *         }
		 *       ],
		 *       "status": 202
		 *     }
		 */
		PhoneNumberChangeResponse: {
			data: components["schemas"]["PhoneNumber"][];
			status: components["schemas"]["StatusAccepted"];
		};
		PhoneNumbersResponse: {
			data: components["schemas"]["PhoneNumber"][];
			status: components["schemas"]["StatusOK"];
		};
		/**
		 * @description The process to be executed when the user successfully
		 *     authenticates. When set to `login`, the user will be logged into the
		 *     account to which the provider account is connected, or if no such
		 *     account exists, a signup will occur. If set to `connect`, the provider
		 *     account will be connected to the list of provider accounts for the
		 *     currently authenticated user.
		 * @example login
		 * @enum {string}
		 */
		Process: "login" | "connect";
		Provider: {
			/**
			 * @description The client ID (in case of OAuth2 or OpenID Connect based providers)
			 * @example 123.apps.googleusercontent.com
			 */
			client_id?: string;
			/** @description The authentication flows the provider integration supports. */
			flows: ("provider_redirect" | "provider_token")[];
			/**
			 * @description The provider ID.
			 * @example google
			 */
			id: string;
			/**
			 * @description The name of the provider.
			 * @example Google
			 */
			name: string;
			/**
			 * @description The OIDC discovery or well-known URL (in case of OAuth2 or OpenID Connect based providers)
			 * @example https://accounts.google.com/.well-known/openid-configuration
			 */
			openid_configuration_url?: string;
		};
		ProviderAccount: {
			/**
			 * @description A name derived from the third-party provider account data.
			 * @example Wizzkid
			 */
			display: string;
			provider: components["schemas"]["Provider"];
			uid: components["schemas"]["ProviderAccountID"];
		};
		/**
		 * @description The provider specific account ID.
		 * @example goo12345
		 */
		ProviderAccountID: string;
		/**
		 * @description The provider ID.
		 * @example google
		 */
		ProviderID: string;
		ProviderList: components["schemas"]["Provider"][];
		ProviderRedirect: {
			/**
			 * @description The URL to return to after the redirect flow is complete.
			 *
			 *     Note that this is not to be mistaken with the callback URL that you
			 *     configure over at the OAuth provider during the OAuth app/client
			 *     setup. The flow is as follows:
			 *
			 *       1. Your frontend redirects to the headless provider redirect
			 *          endpoint in a synchronous (non-XHR) manner, informing allauth
			 *          (by means of `callback_url`) where to redirect to after the
			 *          provider handshake is completed.
			 *
			 *       2. Headless will redirect to the (OAuth) identity provider to
			 *          initiate the handshake, passing along a different callback URL
			 *          to the provider: one that points to an allauth backend URL.
			 *          This is the URL that you need to have setup at your OAuth
			 *          app/client configuration. Note that this must be a backend URL
			 *          as providers can use POST requests to perform their callbacks,
			 *          which is something a frontend would not be able to handle.
			 *
			 *       3. After the authorization at the provider is completed, the
			 *          provider redirects to the *backend* allauth callback URL, which
			 *          will then redirect back to the *frontend* callback URL.
			 *
			 *       4. Your frontend is now expected to fetch the current session to
			 *          determine what the next course of action is. The user could be
			 *          authenticated at this point, or another flow is pending
			 *          (e.g. email verification, or, provider signup). In case of
			 *          errors a `?error=` is passed to the frontend callback URL.
			 * @example https://app.project.org/account/provider/callback
			 */
			callback_url: string;
			process: components["schemas"]["Process"];
			provider: components["schemas"]["ProviderID"];
		};
		ProviderSignup: components["schemas"]["BaseSignup"];
		ProviderToken: {
			process: components["schemas"]["Process"];
			provider: components["schemas"]["ProviderID"];
			/** @description The token. */
			token: {
				/**
				 * @description The access token.
				 * @example 36POk6yJV_adQs
				 */
				access_token?: string;
				client_id: components["schemas"]["ClientID"];
				/**
				 * @description The ID token.
				 * @example eyJhbGciOiJI
				 */
				id_token?: string;
			};
		};
		Reauthenticate: {
			password: components["schemas"]["Password"];
		};
		ReauthenticationRequired: {
			flows: components["schemas"]["Flow"][];
			/** @description A list of methods used to authenticate. */
			methods: components["schemas"]["AuthenticationMethod"][];
			user: components["schemas"]["User"];
		};
		/** @description A response indicating reauthentication is required. */
		ReauthenticationResponse: {
			data: components["schemas"]["ReauthenticationRequired"];
			meta: components["schemas"]["AuthenticatedMeta"];
			/** @enum {integer} */
			status: 401;
		};
		RecoveryCodesAuthenticator: components["schemas"]["BaseAuthenticator"] & {
			/**
			 * @description The total number of recovery codes that initially were available.
			 * @example 10
			 */
			total_code_count: number;
			/**
			 * @description The authenticator type.
			 * @enum {string}
			 */
			type: "recovery_codes";
			/**
			 * @description The number of recovery codes that are unused.
			 * @example 7
			 */
			unused_code_count: number;
		};
		/**
		 * @description The refresh token.
		 * @example eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.QV30
		 */
		RefreshToken: string;
		RequestLoginCode:
			| {
					phone: components["schemas"]["Phone"];
			  }
			| {
					email: components["schemas"]["Email"];
			  };
		RequestPassword: {
			email: components["schemas"]["Email"];
		};
		ResetPassword: {
			/**
			 * @description The password reset key
			 * @example 2f-c4nqd4-e07d9bc694f9f28cd4fe92569d495333
			 */
			key: string;
			password: components["schemas"]["Password"];
		};
		SensitiveRecoveryCodesAuthenticator: components["schemas"]["RecoveryCodesAuthenticator"] & {
			/** @description The list of unused codes. */
			unused_codes: components["schemas"]["AuthenticatorCode"][];
		};
		Session: {
			created_at: components["schemas"]["Timestamp"];
			/** @example 123 */
			id: number;
			/** @example 127.2.3.192 */
			ip: string;
			is_current: boolean;
			last_seen_at?: components["schemas"]["Timestamp"];
			/** @example Mozilla Firefox */
			user_agent: string;
		};
		/** @description The session is expired or invalid. */
		SessionGoneResponse: {
			data: Record<string, never>;
			meta: components["schemas"]["AuthenticationMeta"];
			/** @enum {integer} */
			status: 410;
		};
		Signup: components["schemas"]["BaseSignup"] & {
			password: components["schemas"]["Password"];
		};
		/** @description Configuration of the Django `allauth.socialaccount` app. */
		SocialAccountConfiguration: {
			providers: components["schemas"]["ProviderList"];
		};
		/** @enum {integer} */
		StatusAccepted: 202;
		/** @enum {integer} */
		StatusOK: 200;
		TOTPAuthenticator: components["schemas"]["BaseAuthenticator"] & {
			/** @enum {string} */
			type: "totp";
		};
		/**
		 * @description An epoch based timestamp (trivial to parse using: `new Date(value)*1000`)
		 * @example 1711555057.065702
		 */
		Timestamp: number;
		User: {
			/**
			 * @description The display name for the user.
			 * @example Magic Wizard
			 */
			display: string;
			/**
			 * @description The email address.
			 * @example email@domain.org
			 */
			email?: string;
			/**
			 * @description Whether or not the account has a password set.
			 * @example true
			 */
			has_usable_password: boolean;
			/**
			 * @description The user ID.
			 * @example 123
			 */
			id?: number;
		};
		/** @description Configuration of the Django `allauth.usersessions` app. */
		UserSessionsConfiguration: {
			/** @description Matches `settings.USERSESSIONS_TRACK_ACTIVITY`. */
			track_activity: boolean;
		};
		/**
		 * @description The username.
		 * @example wizard
		 */
		Username: string;
		VerifyEmail: {
			/**
			 * @description The email verification key
			 * @example 2f-c4nqd4-e07d9bc694f9f28cd4fe92569d495333
			 */
			key: string;
		};
		VerifyPhone: {
			/**
			 * @description The phone verification code
			 * @example 4S3H82
			 */
			code: string;
		};
		WebAuthnAuthenticator: components["schemas"]["BaseAuthenticator"] & {
			id: components["schemas"]["AuthenticatorID"];
			/** @description Whether or not this authenticator represents a passkey. Absent if it is not specified. */
			is_passwordless?: boolean;
			/** @example Master key */
			name: string;
			/** @enum {string} */
			type: "webauthn";
		};
		/**
		 * @example {
		 *       "credential": {
		 *         "authenticatorAttachment": "cross-platform",
		 *         "clientExtensionResults": {},
		 *         "id": "-J4JNfPfnLyRSMK4R...",
		 *         "rawId": "-J4JNfPfnLyRSMK4R...",
		 *         "response": {
		 *           "authenticatorData": "SZYN5YgO...",
		 *           "clientDataJSON": "eyJjaGFsbGVuZ2UiOi...",
		 *           "signature": "MEUCIE-7sqILygPqGbrRZ4j2nqeqUU...",
		 *           "userHandle": "Mg..."
		 *         },
		 *         "type": "public-key"
		 *       }
		 *     }
		 */
		WebAuthnCredential: Record<string, never>;
		WebAuthnCredentialCreationOptions: {
			/**
			 * @example {
			 *       "data": {
			 *         "request_options": {
			 *           "publicKey": {
			 *             "allowCredentials": [],
			 *             "challenge": "aOecJJtLA2e-Dj2WU-zbRoJewbQqSUPxoA9EzsUL72o",
			 *             "rpId": "localhost",
			 *             "userVerification": "preferred"
			 *           }
			 *         }
			 *       },
			 *       "status": 200
			 *     }
			 */
			creation_options: Record<string, never>;
		};
		WebAuthnCredentialRequestOptions: {
			/**
			 * @example {
			 *       "data": {
			 *         "request_options": {
			 *           "publicKey": {
			 *             "allowCredentials": [],
			 *             "challenge": "aOecJJtLA2e-Dj2WU-zbRoJewbQqSUPxoA9EzsUL72o",
			 *             "rpId": "localhost",
			 *             "userVerification": "preferred"
			 *           }
			 *         }
			 *       },
			 *       "status": 200
			 *     }
			 */
			request_options: Record<string, never>;
		};
	};
	responses: {
		/** @description The account prohibits adding an authenticator, e.g. because of an unverified email address. */
		AddAuthenticatorConflict: {
			headers: {
				[name: string]: unknown;
			};
			content: {
				"application/json": components["schemas"]["ConflictResponse"];
			};
		};
		/** @description A WebAuthn authenticator. */
		AddWebAuthnAuthenticator: {
			headers: {
				[name: string]: unknown;
			};
			content: {
				"application/json": {
					data: components["schemas"]["WebAuthnAuthenticator"];
					meta: {
						/** @description Whether or not recovery codes where generated automatically. */
						recovery_codes_generated?: boolean;
					};
					status: components["schemas"]["StatusOK"];
				};
			};
		};
		/** @description The user is authenticated. */
		Authenticated: {
			headers: {
				[name: string]: unknown;
			};
			content: {
				"application/json": components["schemas"]["AuthenticatedResponse"];
			};
		};
		/** @description Authenticated by code. */
		AuthenticatedByCode: {
			headers: {
				[name: string]: unknown;
			};
			content: {
				"application/json": components["schemas"]["AuthenticatedResponse"];
			};
		};
		/** @description Authenticated by password. */
		AuthenticatedByPassword: {
			headers: {
				[name: string]: unknown;
			};
			content: {
				"application/json": components["schemas"]["AuthenticatedResponse"];
			};
		};
		/** @description Authenticated by password and 2FA. */
		AuthenticatedByPasswordAnd2FA: {
			headers: {
				[name: string]: unknown;
			};
			content: {
				"application/json": components["schemas"]["AuthenticatedResponse"];
			};
		};
		/** @description Not authenticated. */
		Authentication: {
			headers: {
				[name: string]: unknown;
			};
			content: {
				"application/json": components["schemas"]["AuthenticationResponse"];
			};
		};
		/** @description The response indicates authentication or re-authentication is required. */
		AuthenticationOrReauthentication: {
			headers: {
				[name: string]: unknown;
			};
			content: {
				"application/json":
					| components["schemas"]["AuthenticationResponse"]
					| components["schemas"]["ReauthenticationResponse"];
			};
		};
		/** @description List of authenticators. */
		Authenticators: {
			headers: {
				[name: string]: unknown;
			};
			content: {
				"application/json": {
					data: components["schemas"]["AuthenticatorList"];
					status: components["schemas"]["StatusOK"];
				};
			};
		};
		/** @description The django-allauth configuration. */
		Configuration: {
			headers: {
				[name: string]: unknown;
			};
			content: {
				"application/json": components["schemas"]["ConfigurationResponse"];
			};
		};
		/** @description List of email addresses. */
		EmailAddresses: {
			headers: {
				[name: string]: unknown;
			};
			content: {
				"application/json": {
					data: components["schemas"]["EmailAddress"][];
					status: components["schemas"]["StatusOK"];
				};
			};
		};
		/** @description Email verification information. */
		EmailVerificationInfo: {
			headers: {
				[name: string]: unknown;
			};
			content: {
				"application/json": components["schemas"]["EmailVerificationInfo"];
			};
		};
		/** @description An input error occurred. */
		Error: {
			headers: {
				[name: string]: unknown;
			};
			content: {
				"application/json": components["schemas"]["ErrorResponse"];
			};
		};
		/** @description A forbidden response. */
		Forbidden: {
			headers: {
				[name: string]: unknown;
			};
			content: {
				"application/json": components["schemas"]["ForbiddenResponse"];
			};
		};
		/** @description Not found. */
		NotFound: {
			headers: {
				[name: string]: unknown;
			};
			content: {
				"application/json": {
					/** @enum {integer} */
					status: 404;
				};
			};
		};
		/** @description Information about the password reset key. */
		PasswordResetInfo: {
			headers: {
				[name: string]: unknown;
			};
			content: {
				"application/json": {
					data: {
						user?: components["schemas"]["User"];
					};
					status: components["schemas"]["StatusOK"];
				};
			};
		};
		/** @description List of phone numbers. */
		PhoneNumbers: {
			headers: {
				[name: string]: unknown;
			};
			content: {
				"application/json": components["schemas"]["PhoneNumbersResponse"];
			};
		};
		/** @description List of third-party provider accounts. */
		ProviderAccounts: {
			headers: {
				[name: string]: unknown;
			};
			content: {
				"application/json": {
					data: components["schemas"]["ProviderAccount"][];
					status: components["schemas"]["StatusOK"];
				};
			};
		};
		/** @description Information relating to the pending provider signup. */
		ProviderSignup: {
			headers: {
				[name: string]: unknown;
			};
			content: {
				"application/json": {
					data: {
						account: components["schemas"]["ProviderAccount"];
						email: components["schemas"]["EmailAddress"][];
						user: components["schemas"]["User"];
					};
					status: components["schemas"]["StatusOK"];
				};
			};
		};
		/** @description The response indicates reauthentication is required. */
		ReauthenticationRequired: {
			headers: {
				[name: string]: unknown;
			};
			content: {
				"application/json": components["schemas"]["ReauthenticationResponse"];
			};
		};
		/** @description Information on the recovery codes. */
		RecoveryCodes: {
			headers: {
				[name: string]: unknown;
			};
			content: {
				"application/json": {
					data: components["schemas"]["SensitiveRecoveryCodesAuthenticator"];
					status: components["schemas"]["StatusOK"];
				};
			};
		};
		/** @description A new access token (and optionally new refresh token). */
		RefreshToken: {
			headers: {
				[name: string]: unknown;
			};
			content: {
				"application/json": {
					data: {
						access_token: components["schemas"]["AccessToken"];
						refresh_token?: components["schemas"]["RefreshToken"];
					};
					status: components["schemas"]["StatusOK"];
				};
			};
		};
		/** @description The response indicates session is invalid or no longer exists. */
		SessionGone: {
			headers: {
				[name: string]: unknown;
			};
			content: {
				"application/json": components["schemas"]["SessionGoneResponse"];
			};
		};
		/** @description List of sessions. */
		Sessions: {
			headers: {
				[name: string]: unknown;
			};
			content: {
				"application/json": {
					data: components["schemas"]["Session"][];
					status: components["schemas"]["StatusOK"];
				};
			};
		};
		/** @description A success response. */
		StatusOK: {
			headers: {
				[name: string]: unknown;
			};
			content: {
				"application/json": {
					status: components["schemas"]["StatusOK"];
				};
			};
		};
		/** @description Information on the TOTP authenticator. */
		TOTPAuthenticator: {
			headers: {
				[name: string]: unknown;
			};
			content: {
				"application/json": {
					data: components["schemas"]["TOTPAuthenticator"];
					meta?: {
						/** @description Whether or not recovery codes where generated automatically. */
						recovery_codes_generated?: boolean;
					};
					status: components["schemas"]["StatusOK"];
				};
			};
		};
		/** @description No TOTP authenticator has been set up. */
		TOTPAuthenticatorNotFound: {
			headers: {
				[name: string]: unknown;
			};
			content: {
				"application/json": {
					meta: {
						/**
						 * @description A TOTP secret that can be used to setup a new authenticator.
						 * @example J4ZKKXTK7NOVU7EPUVY23LCDV4T2QZYM
						 */
						secret: string;
						/**
						 * @description otpauth URI from which a QR code can be generated and scanned by OTP clients.
						 * @example otpauth://totp/Example:alice@fsf.org?secret=JBSWY3DPEHPK3PXP&issuer=Example
						 */
						totp_url: string;
					};
					/** @enum {integer} */
					status: 404;
				};
			};
		};
		/** @description Too many requests. */
		TooManyRequests: {
			headers: {
				[name: string]: unknown;
			};
			content: {
				"application/json": {
					/** @enum {integer} */
					status: 429;
				};
			};
		};
		/** @description There is no authenticated session. */
		Unauthenticated: {
			headers: {
				[name: string]: unknown;
			};
			content: {
				"application/json": components["schemas"]["AuthenticationResponse"];
			};
		};
		/** @description A WebAuthn authenticator. */
		WebAuthnAuthenticator: {
			headers: {
				[name: string]: unknown;
			};
			content: {
				"application/json": {
					data: components["schemas"]["WebAuthnAuthenticator"];
					status: components["schemas"]["StatusOK"];
				};
			};
		};
		/** @description WebAuthn credential creation options. */
		WebAuthnCreationOptionsResponse: {
			headers: {
				[name: string]: unknown;
			};
			content: {
				"application/json": {
					data: components["schemas"]["WebAuthnCredentialCreationOptions"];
					status: components["schemas"]["StatusOK"];
				};
			};
		};
		/** @description WebAuthn credential request options. */
		WebAuthnRequestOptionsResponse: {
			headers: {
				[name: string]: unknown;
			};
			content: {
				"application/json": {
					data: components["schemas"]["WebAuthnCredentialRequestOptions"];
					status: components["schemas"]["StatusOK"];
				};
			};
		};
	};
	parameters: {
		/** @description The type of client accessing the API. */
		Client: "app" | "browser";
		/** @description The email verification key */
		EmailVerificationKey: string;
		/**
		 * @description When present (regardless of its value), enables passwordless sign-in via a WebAuthn credential (Passkey),
		 *     but may enforce additional multi-factor authentication (MFA) requirements. Omit the parameter to disable.
		 */
		PasswordLess: boolean;
		/** @description The password reset key */
		PasswordResetKey: string;
		/** @description Session token. Only needed when `client` is equal to `app`. */
		SessionToken: string;
	};
	requestBodies: {
		AddWebAuthnAuthenticator: {
			content: {
				"application/json": {
					credential: components["schemas"]["WebAuthnCredential"];
					/** @example Master key */
					name?: string;
				};
			};
		};
		/** @description Authenticate using WebAuthn. */
		AuthenticateWebAuthn: {
			content: {
				"application/json": {
					credential: components["schemas"]["WebAuthnCredential"];
				};
			};
		};
		ChangePassword: {
			content: {
				"application/json": {
					current_password?: components["schemas"]["Password"];
					/**
					 * @description The current password.
					 * @example Aberto!
					 */
					new_password: string;
				};
			};
		};
		ConfirmLoginCode: {
			content: {
				"application/json": components["schemas"]["ConfirmLoginCode"];
			};
		};
		DeleteWebAuthn: {
			content: {
				"application/json": {
					/** @description The IDs of the authenticator that are to be deleted. */
					authenticators: components["schemas"]["AuthenticatorID"][];
				};
			};
		};
		Email: {
			content: {
				"application/json": {
					email: components["schemas"]["Email"];
				};
			};
		};
		EndSessions: {
			content: {
				"application/json": components["schemas"]["EndSessions"];
			};
		};
		/** @description Login. */
		Login: {
			content: {
				"application/json": components["schemas"]["Login"];
			};
		};
		/** @description Login using WebAuthn. */
		LoginWebAuthn: {
			content: {
				"application/json": {
					credential: components["schemas"]["WebAuthnCredential"];
				};
			};
		};
		MFAAuthenticate: {
			content: {
				"application/json": components["schemas"]["MFAAuthenticate"];
			};
		};
		MFATrust: {
			content: {
				"application/json": components["schemas"]["MFATrust"];
			};
		};
		MarkPrimaryEmail: {
			content: {
				"application/json": {
					/**
					 * @description An email address.
					 * @example email@domain.org
					 */
					email: string;
					/**
					 * @description Primary flag.
					 * @enum {boolean}
					 */
					primary: true;
				};
			};
		};
		/** @description Signup using a passkey */
		PasskeySignup: {
			content: {
				"application/json": components["schemas"]["PasskeySignup"];
			};
		};
		Phone: {
			content: {
				"application/json": {
					/** @example +314159265359 */
					phone: string;
				};
			};
		};
		ProviderAccount: {
			content: {
				"application/json": {
					account: components["schemas"]["ProviderAccountID"];
					provider: components["schemas"]["ProviderID"];
				};
			};
		};
		/** @description Initiate the provider redirect flow. */
		ProviderRedirect: {
			content: {
				"application/x-www-form-urlencoded": components["schemas"]["ProviderRedirect"];
			};
		};
		/** @description Provider signup. */
		ProviderSignup: {
			content: {
				"application/json": components["schemas"]["ProviderSignup"];
			};
		};
		ProviderToken: {
			content: {
				"application/json": components["schemas"]["ProviderToken"];
			};
		};
		/** @description Reauthenticate. */
		Reauthenticate: {
			content: {
				"application/json": components["schemas"]["Reauthenticate"];
			};
		};
		/** @description Reauthenticate using WebAuthn. */
		ReauthenticateWebAuthn: {
			content: {
				"application/json": {
					credential: components["schemas"]["WebAuthnCredential"];
				};
			};
		};
		RefreshToken: {
			content: {
				"application/json": {
					refresh_token: components["schemas"]["RefreshToken"];
				};
			};
		};
		/** @description Request a login code. */
		RequestLoginCode: {
			content: {
				"application/json": components["schemas"]["RequestLoginCode"];
			};
		};
		/** @description Request password. */
		RequestPassword: {
			content: {
				"application/json": components["schemas"]["RequestPassword"];
			};
		};
		ResetPassword: {
			content: {
				"application/json": components["schemas"]["ResetPassword"];
			};
		};
		SetupTOTP: {
			content: {
				"application/json": {
					code: components["schemas"]["AuthenticatorCode"];
				};
			};
		};
		/** @description Signup */
		Signup: {
			content: {
				"application/json": components["schemas"]["Signup"];
			};
		};
		UpdateWebAuthn: {
			content: {
				"application/json": {
					id?: components["schemas"]["AuthenticatorID"];
					/** @example Master key */
					name?: string;
				};
			};
		};
		VerifyEmail: {
			content: {
				"application/json": components["schemas"]["VerifyEmail"];
			};
		};
		VerifyPhone: {
			content: {
				"application/json": components["schemas"]["VerifyPhone"];
			};
		};
	};
	headers: never;
	pathItems: never;
}
export type $defs = Record<string, never>;
export type operations = Record<string, never>;
